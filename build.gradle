import org.gradle.process.internal.ExecException

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'application'
apply plugin: 'nebula.ospackage'

sourceCompatibility = 1.8

def protobufVersion = '3.2.0'
def logbackConfig = "logback.xml"

// workaround to force gradle to download not just the dependencies for --offline use
// but also the plugins
buildscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        if (gradle.startParameter.isOffline()) {
            classpath fileTree(dir: "$projectDir/libs/plugins")
        } else {
            classpath "com.netflix.nebula:gradle-ospackage-plugin:4.9.3"
        }
    }
}

subprojects {
    apply plugin: 'java'
    group 'com.linbit'
    sourceCompatibility = 1.8

    repositories {
        mavenCentral()

        flatDir {
            dirs 'libs'
        }
    }

    dependencies {
        if (gradle.startParameter.isOffline()) {
            compile fileTree(dir: "libs/compile")
            runtime fileTree(dir: "libs/runtime")
            testCompile fileTree(dir: "libs/testCompile")
            testRuntime fileTree(dir: "libs/testRuntime")
        } else {
            compile group: 'com.google.inject', name: 'guice', version: '4.2.0'
            compile group: 'com.google.inject.extensions', name: 'guice-assistedinject', version: '4.2.0'

            compile group: 'com.google.protobuf', name: 'protobuf-java', version: protobufVersion

            compile 'info.picocli:picocli:2.3.0'
            compile group: 'org.slf4j', name: 'slf4j-api', version: '1.7.25'
            compile group: 'ch.qos.logback', name: 'logback-classic', version: '1.2.3'
        }
    }
}

project(':server') {
    apply plugin: 'application'

    mainClassName = 'com.linbit.linstor.core.Satellite'

    sourceSets {
        main {
        java {
            srcDirs = ["src/main/java", "generated-src"]
        }
        resources {
            srcDirs = ["src/main/resources", "generated-resources"]
        }
        }
        test {
            java {
            srcDirs = ["src/test/java"]
            }
        }
    }

    distributions {
        main {
            contents {
                from(logbackConfig) {
                    into("lib/conf")
                }
            }
        }
    }
/////////////////////////// Version Info ///////////////////////////
    task versionInfo() {
        String propsFile = "$projectDir/generated-resources/version-info.properties"

        if (project.hasProperty('versionOverride')) {
            logger.warn("Overriding version with $versionOverride")
            version = versionOverride
        }

        if (!project.hasProperty('versionOverride')) {
            File gitFolder = file("$projectDir/../.git")
            if (gitFolder.exists())
            {
                try {
                    def stdOut = new ByteArrayOutputStream()
                    def stdErr = new ByteArrayOutputStream()
                    project.exec {
                        commandLine 'make', '-C', '..', 'versioninfo'
                        standardOutput = stdOut
                        errorOutput = stdErr
                    }
                } catch (ExecException exc) {
                    throw new RuntimeException("Cannot generate version.", exc)
                }
            }

            Properties props = new Properties()
            try {
                props.load(new FileInputStream(propsFile))
            } catch (Exception exc) {
                throw new RuntimeException("Cannot read version.", exc)
            }
            version = props.get("version")
        }
    }

    processResources.dependsOn versionInfo

    clean {
        delete "${projectDir}/generated-resources"
    }
}

project(':satellite') {
    apply plugin: 'application'

    dependencies {
        compile project(':server')
    }

    sourceSets {
        main {
            java {
                srcDirs = ["src/main/java"]
            }
            resources {
                srcDirs = ["src/main/resources"]
            }
        }
        test {
            java {
                srcDirs = ["src/test/java"]
            }
        }
    }

    startScripts.enabled = false
    task SatelliteStartup(type: CreateStartScripts) {
        mainClassName = 'com.linbit.linstor.core.Satellite'
        applicationName = "Satellite"
        outputDir = new File(project.buildDir, 'satellite')
        classpath = jar.outputs.files + project.configurations.runtime + files('conf')
        doLast {
            delete windowsScript
        }
    }

    distributions {
        main {
            contents {
                from(SatelliteStartup) {
                    into("bin")
                }
            }
        }
    }
}

version = project(':server').version
project(':controller').version = version
project(':satellite').version = version

project(':controller') {
    apply plugin: 'application'

    dependencies {
        compile project(':server')
        testCompile project(':server')

        if (gradle.startParameter.isOffline()) {
            compile fileTree(dir: "libs/compile")
            runtime fileTree(dir: "libs/runtime")
            testCompile fileTree(dir: "libs/testCompile")
            testRuntime fileTree(dir: "libs/testRuntime")
        } else {
            compile group: 'org.apache.commons', name: 'commons-dbcp2', version: '2.2.0'
            compile group: 'org.apache.commons', name: 'commons-pool2', version: '2.5.0'
            compile group: 'org.flywaydb', name: 'flyway-core', version: '5.0.7'
            runtime group: 'com.h2database', name: 'h2', version: '1.4.197'
        }

//    runtime group: 'org.postgresql', name: 'postgresql', version: '42.2.2'
    }

    sourceSets {
        main {
            java {
                srcDirs = ["src/main/java"]
            }
            resources {
                srcDirs = ["src/main/resources"]
            }
        }
        test {
            java {
                srcDirs = ["src/test/java"]
            }
        }
    }

    startScripts.enabled = false
    task ControllerStartup(type: CreateStartScripts) {
        mainClassName = 'com.linbit.linstor.core.Controller'
        applicationName = "Controller"
        outputDir = new File(project.buildDir, 'controller')
        classpath = jar.outputs.files + project.configurations.runtime + files('conf')
        doLast {
            delete windowsScript
        }
    }

    distributions {
        main {
            contents {
                from(ControllerStartup) {
                    into("bin")
                }
            }
        }
    }
}

repositories
{
    mavenCentral()

    flatDir {
       dirs 'libs'
    }
}

sourceSets {
    test {
        java {
            srcDirs = ["src/test/java"]
        }
    }
}

dependencies {
    compile project(':controller'), project(':satellite')
    testCompile project(':controller'), project(':satellite')

    testCompile group: 'junit', name: 'junit', version: '4.+'
    testCompile group: 'org.powermock', name: 'powermock-mockito-release-full', version: '1.6.4'

    testCompile group: 'org.assertj', name: 'assertj-core', version: '3.9.0'
    testCompile group: 'pl.pragmatists', name: 'JUnitParams', version: '1.1.1'

    testCompile group: 'com.google.inject.extensions', name: 'guice-testlib', version: '4.1.0'
}

/////////////////////////// Start scripts ///////////////////////////
startScripts.enabled = false

task ControllerStartup(type: CreateStartScripts) {
    mainClassName = 'com.linbit.linstor.core.Controller'
    applicationName = "Controller"
    outputDir = new File(project.buildDir, 'controller')
    classpath = jar.outputs.files + project.configurations.runtime + files('conf')
    doLast {
        delete windowsScript
    }
}


task SatelliteStartup(type: CreateStartScripts) {
    mainClassName = 'com.linbit.linstor.core.Satellite'
    applicationName = "Satellite"
    outputDir = new File(project.buildDir, 'satellite')
    classpath = jar.outputs.files + project.configurations.runtime + files('conf')
    doLast {
        delete windowsScript
    }
}

task LinstorConfigStartup(type: CreateStartScripts) {
    mainClassName = 'com.linbit.linstor.core.LinstorConfig'
    applicationName = "linstor-config"
    outputDir = new File(project.buildDir, 'linstorconfig')
    classpath = jar.outputs.files + project.configurations.runtime
    doLast {
        delete windowsScript
    }
}

distributions {
    main {
        contents {
            from(ControllerStartup) {
                into("bin")
            }
            from(SatelliteStartup) {
                into("bin")
            }
            from(LinstorConfigStartup) {
                into("bin")
            }
            from(logbackConfig) {
                into("lib/conf")
            }
        }
    }
}

task showMeCache {
    doLast {
        configurations.compile.each { println it }
        configurations.runtime.each { println it }
    }
}

task showMeTestCache {
    doLast {
        configurations.testCompile.each { println it }
    }
}

/////////////////////////// Test commands ///////////////////////////
task buildTestCommands(type:Exec) {
  workingDir 'test-support'

  commandLine 'make'

  //store the output instead of printing to the console:
  standardOutput = new ByteArrayOutputStream()

  //extension method buildTestCommands.output() can be used to obtain the output:
  ext.output = {
    return standardOutput.toString()
  }
}

task unzip(type: Copy) {
    def zipFile = file("tools/protoc-" + protobufVersion + '-linux-x86_64.zip')
    def outputDir = file("tools/protoc-" + protobufVersion)

    from zipTree(zipFile)
    into outputDir
}

task downloadProtoc {
    outputs.dir "tools"
    def protozip = new File("${projectDir}/tools/protoc-" + protobufVersion + '-linux-x86_64.zip')
    outputs.file protozip

    doLast {
        if (!protozip.exists()) {
            mkdir "tools"
            println "downloading protoc..."
            new URL('https://github.com/google/protobuf/releases/download/v'
                    + protobufVersion + '/protoc-' + protobufVersion + '-linux-x86_64.zip')
                    .withInputStream { i -> protozip.withOutputStream { it << i}}
        }
    }
}

task getProtoc {
    dependsOn downloadProtoc, unzip
}

def protoc = file("${projectDir}/tools/protoc-" + protobufVersion + '/bin/protoc')

/**
 * Generates Java sources from common API definitions. This includes the protobuf compilation.
 *
 * For package builds this task is run in the 'make debrelease' stage, the generated sources are bundled in the package
 * tarball, and it is then skipped when the package is finally built.
 */
task generateJava(type:Exec) {
    doFirst {
        if (!protoc.exists()) {
            throw new GradleException("'protoc' binary not found; run the task 'getProtoc' to download the binary")
        }
    }

    workingDir 'linstor-common'

    commandLine 'make', "PROTOC=" + protoc, 'java'
}

task cleanCommon(type:Exec) {
    workingDir 'linstor-common'

    commandLine 'make', 'cleanjava'
}

task cleanTestCommands(type:Exec) {
  workingDir 'test-support'

  commandLine 'make', 'clean'

  //store the output instead of printing to the console:
  standardOutput = new ByteArrayOutputStream()

  //extension method buildTestCommands.output() can be used to obtain the output:
  ext.output = {
    return standardOutput.toString()
  }
}

compileJava {
    dependsOn generateJava
}

compileTestJava {
  dependsOn buildTestCommands
}

clean {
    dependsOn cleanTestCommands, cleanCommon
}

/////////////////////////// Dependency resolution ///////////////////////////
task resolveDependencies {
    doLast {
        project.rootProject.allprojects.each { subProject ->
            subProject.buildscript.configurations.each { configuration ->
                resolveConfiguration(configuration)
            }
            subProject.configurations.each { configuration ->
                resolveConfiguration(configuration)
            }
        }
    }
}

static void resolveConfiguration(configuration) {
    def nonResolveableConfigurations =
            ['apiElements', 'implementation', 'runtimeElements', 'runtimeOnly', 'testImplementation',
             'testRuntimeOnly', 'generatedImplementation', 'generatedRuntimeOnly']

    if (!nonResolveableConfigurations.contains(configuration.getName())) {
        configuration.resolve()
    }
}

/////////////////////////// Packaging ///////////////////////////
ospackage {
    packageName 'linstor-server'
    release '1'
    os = LINUX
    user 'root'
    packager 'LINBIT HA-Solutions GmbH <drbd-user@lists.linbit.com>'

    requires('drbd-utils', '9.2.0', GREATER | EQUAL)

    postInstall file('scripts/postinstall.sh')

    from('scripts/linstor-controller.service') {
        into '/lib/systemd/system'
        fileMode 0644
    }
    from('scripts/linstor-satellite.service') {
        into '/lib/systemd/system'
        fileMode 0644
    }

    into '/usr/share/linstor-server'
    from(jar.outputs.files) {
        into 'lib'
    }
    from(configurations.runtime) {
        into 'lib'
    }
    from(logbackConfig) {
        into 'lib/conf'
    }
    from(ControllerStartup) {
        into 'bin'
        fileMode 0550
    }
    from(SatelliteStartup) {
        into 'bin'
        fileMode 0550
    }
    from(LinstorConfigStartup) {
        into 'bin'
        fileMode 0550
    }
}

// we might even split these to generate separate controller/satellite packages
buildRpm {
    requires('jre-headless', "1.8.0", GREATER | EQUAL)
    requires('lvm2')

    from('scripts/firewalld/drbd.xml') {
        into '/usr/lib/firewalld/services'
        fileMode 0644
    }
    from('scripts/firewalld/linstor-controller.xml') {
        into '/usr/lib/firewalld/services'
        fileMode 0644
    }
    from('scripts/firewalld/linstor-satellite.xml') {
        into '/usr/lib/firewalld/services'
        fileMode 0644
    }
}

buildDeb {
    requires('default-jre-headless')
    requires('thin-provisioning-tools')
}

task deleteLibs(type: Delete) {
    doLast {
        subprojects.each { prj ->
            delete "${prj.name}/libs"
        }
        delete "${projectDir}/libs/plugins"
    }
}

task copyToLibs(dependsOn: 'deleteLibs') {
    doLast {
        subprojects.each { prj ->
            ['compile', 'runtime'].each { scope ->
                copy {
                    from prj.configurations.getByName(scope).files
                    into "${prj.name}/libs/${scope}"
                }
            }
        }
        copy {
            from buildscript.configurations.classpath
            into "${projectDir}/libs/plugins"
        }
    }
}

// this task is needed for RPM packaging
// it creates a list of dependency jars needed for the server project
task showServerRuntimeLibs() {
	doLast {
		project(':server').configurations.getByName('runtime').files.each { f ->
			print('/usr/share/linstor-server/lib/' + f.getName().toString() + '\n')
		}
	}
}

