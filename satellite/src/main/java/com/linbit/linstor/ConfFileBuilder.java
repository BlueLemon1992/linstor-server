package com.linbit.linstor;

import com.linbit.ImplementationError;
import com.linbit.InvalidNameException;
import com.linbit.linstor.Resource.RscFlags;
import com.linbit.linstor.api.ApiConsts;
import com.linbit.linstor.api.prop.WhitelistProps;
import com.linbit.linstor.core.LinStor;
import com.linbit.linstor.api.prop.LinStorObject;
import com.linbit.linstor.logging.ErrorReporter;
import com.linbit.linstor.propscon.InvalidKeyException;
import com.linbit.linstor.propscon.Props;
import com.linbit.linstor.security.AccessContext;
import com.linbit.linstor.security.AccessDeniedException;

import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import org.slf4j.event.Level;

public class ConfFileBuilder
{
    private static final ResourceNameComparator RESOURCE_NAME_COMPARATOR = new ResourceNameComparator();

    private final ErrorReporter errorReporter;
    private final AccessContext accCtx;
    private final Resource localRsc;
    private final Collection<Resource> remoteResources;
    private final WhitelistProps whitelistProps;

    private StringBuilder stringBuilder;
    private int indentDepth;


    public ConfFileBuilder(
        final ErrorReporter errorReporterRef,
        final AccessContext accCtxRef,
        final Resource localRscRef,
        final Collection<Resource> remoteResourcesRef,
        final WhitelistProps whitelistPropsRef
    )
    {
        errorReporter = errorReporterRef;
        accCtx = accCtxRef;
        localRsc = localRscRef;
        remoteResources = remoteResourcesRef;
        whitelistProps = whitelistPropsRef;

        stringBuilder = new StringBuilder();
        indentDepth = 0;
    }

    // Constructor used for the common linstor conf
    public ConfFileBuilder(
        final ErrorReporter errorReporterRef,
        final WhitelistProps whitelistPropsRef
    )
    {
        errorReporter = errorReporterRef;
        accCtx = null;
        localRsc = null;
        remoteResources = null;
        whitelistProps = whitelistPropsRef;

        stringBuilder = new StringBuilder();
        indentDepth = 0;
    }

    private String header()
    {
        return String.format("# This file was generated by linstor(%s), do not edit manually.",
            LinStor.VERSION_INFO_PROVIDER.getVersion());
    }

    public String build()
        throws AccessDeniedException
    {
        Set<Resource> peerRscSet = new TreeSet<>(RESOURCE_NAME_COMPARATOR);
        peerRscSet.addAll(remoteResources); // node-alphabetically sorted
        Set<Resource> clients = new TreeSet<>(RESOURCE_NAME_COMPARATOR);
        Set<Resource> satellites = new TreeSet<>(RESOURCE_NAME_COMPARATOR);

        final Set<Set<String>> nodeMeshes = new HashSet<>();
        final Map<String, List<String>> singleConnections = new HashMap<>();

        final ResourceDefinition rscDfn = localRsc.getDefinition();

        appendLine(header());
        appendLine("");
        appendLine("resource \"%s\"", localRsc.getDefinition().getName().displayValue);
        try (Section resourceSection = new Section())
        {
            // include linstor common
            appendLine("template-file \"linstor_common.conf\";");

            appendDrbdOptions(
                LinStorObject.CONTROLLER,
                rscDfn.getProps(accCtx),
                ApiConsts.NAMESPC_DRBD_RESOURCE_OPTIONS
            );

            appendLine("net");
            try (Section netSection = new Section())
            {
                // TODO: make configurable
                appendLine("cram-hmac-alg     %s;", "sha1");
                // TODO: make configurable
                appendLine("shared-secret     \"%s\";", localRsc.getDefinition().getSecret(accCtx));

                appendDrbdOptions(
                    LinStorObject.CONTROLLER,
                    rscDfn.getProps(accCtx),
                    ApiConsts.NAMESPC_DRBD_NET_OPTIONS
                );
            }

            if (rscDfn.getProps(accCtx).getNamespace(ApiConsts.NAMESPC_DRBD_DISK_OPTIONS).isPresent())
            {
                appendLine("disk");
                try (Section ignore = new Section())
                {
                    appendDrbdOptions(
                        LinStorObject.CONTROLLER,
                        rscDfn.getProps(accCtx),
                        ApiConsts.NAMESPC_DRBD_DISK_OPTIONS
                    );
                }
            }

            // TODO: print options properties

            if (localRsc.getStateFlags().isSet(accCtx, RscFlags.DISKLESS))
            {
                clients.add(localRsc);
            }
            else
            {
                satellites.add(localRsc);
            }

            int port = localRsc.getDefinition().getPort(accCtx).value;
            // Create local network configuration
            {
                NetInterface localNetIf = getPreferredNetIf(localRsc);
                LsIpAddress localAddr = localNetIf.getAddress(accCtx);

                String localAddrText = localAddr.getAddress();
                appendLine("on %s", localRsc.getAssignedNode().getName().displayValue);
                try (Section onSection = new Section())
                {
                    Iterator<Volume> vlmIterator = localRsc.iterateVolumes();
                    while (vlmIterator.hasNext())
                    {
                        appendVlmIfPresent(vlmIterator.next(), accCtx);
                    }
                    if (localAddr.getAddressType() == LsIpAddress.AddrType.IPv6)
                    {
                        appendLine("address    ipv6 [%s]:%d;", localAddrText, port);
                    }
                    else
                    {
                        appendLine("address    ipv4 %s:%d;", localAddrText, port);
                    }
                    appendLine("node-id    %d;", localRsc.getNodeId().value);
                }
            }

            for (final Resource peerRsc : peerRscSet)
            {
                if (peerRsc.getStateFlags().isUnset(accCtx, RscFlags.DELETE))
                {
                    NetInterface peerNetIf = getPreferredNetIf(peerRsc);
                    LsIpAddress peerAddr = peerNetIf.getAddress(accCtx);

                    String peerAddrText = peerAddr.getAddress();
                    appendLine("");
                    appendLine("on %s", peerRsc.getAssignedNode().getName().displayValue);
                    try (Section onSection = new Section())
                    {
                        Iterator<Volume> peerVlms = peerRsc.iterateVolumes();
                        while (peerVlms.hasNext())
                        {
                            appendVlmIfPresent(peerVlms.next(), accCtx);
                        }

                        if (peerAddr.getAddressType() == LsIpAddress.AddrType.IPv6)
                        {
                            appendLine("address    ipv6 [%s]:%d;", peerAddrText, port);
                        }
                        else
                        {
                            appendLine("address    ipv4 %s:%d;", peerAddrText, port);
                        }
                        appendLine("node-id    %d;", peerRsc.getNodeId().value);

                        // TODO: implement "multi-connection / path magic" (nodeMeshes + singleConnections vars)
                        // sb.append(peerResource.co)
                    }
                }
            }

            // TODO: find a better way to generate the connections
            // first generate all with local first
            for (final Resource peerRsc : peerRscSet)
            {
                // don't create a connection entry if the resource has the deleted flag
                // or if it is a connection between two diskless nodes
                if (peerRsc.getStateFlags().isUnset(accCtx, RscFlags.DELETE) &&
                        !(peerRsc.getStateFlags().isSet(accCtx, RscFlags.DISKLESS) &&
                            localRsc.getStateFlags().isSet(accCtx, RscFlags.DISKLESS)))
                {
                    Node fromNode = localRsc.getAssignedNode();
                    Node toNode = peerRsc.getAssignedNode();

                    String fromHost = fromNode.getName().displayValue;
                    String toHost = toNode.getName().displayValue;

                    appendLine("connection");
                    try (Section connectionSection = new Section())
                    {
                        String format = "host %s;";
                        appendLine(format, fromHost);
                        appendLine(format, toHost);

                        ResourceConnection rscConn = localRsc.getResourceConnection(accCtx, peerRsc);

                        if (rscConn != null)
                        {
                            if (rscConn.getProps(accCtx)
                                .getNamespace(ApiConsts.NAMESPC_DRBD_PEER_DEVICE_OPTIONS).isPresent()
                                )
                            {
                                appendLine("");
                                appendLine("disk");
                                try (Section ignore = new Section())
                                {
                                    appendDrbdOptions(
                                        LinStorObject.CONTROLLER,
                                        rscConn.getProps(accCtx),
                                        ApiConsts.NAMESPC_DRBD_PEER_DEVICE_OPTIONS
                                    );
                                }
                            }
                        }
                    }
                }
            }

            // FIXME: dead code (for connection meshes)
            // if (!nodeMeshes.isEmpty())
            // {
            //     appendLine("connection-mesh");
            //     try (Section connectionMeshSection = new Section())
            //     {
            //         for (final Set<String> mesh : nodeMeshes)
            //         {
            //             appendIndent();
            //             append("hosts");
            //             for (String node : mesh)
            //             {
            //                 append(" ");
            //                 append(node);
            //             }
            //             appendLine(";");
            //         }
            //     }
            // }
            //
            // if (!singleConnections.isEmpty())
            // {
            //     final Set<Entry<String,List<String>>> entrySet = singleConnections.entrySet();
            //     for (final Entry<String, List<String>> entry : entrySet)
            //     {
            //         final String source = entry.getKey();
            //         final List<String> targets = entry.getValue();
            //         for (final String target : targets)
            //         {
            //             appendLine("connection");
            //             try (Section connectionSection = new Section())
            //             {
            //                 appendLine("host %s;", source);
            //                 appendLine("host %s;", target);
            //             }
            //         }
            //     }
            // }
        }

        return stringBuilder.toString();
    }

    public String buildCommonConf(final Props satelliteProps)
    {
        appendLine(header());
        appendLine("");
        appendLine("common");
        try (Section commonSection = new Section())
        {
            if (satelliteProps.getNamespace(ApiConsts.NAMESPC_DRBD_DISK_OPTIONS).isPresent() ||
                satelliteProps.getNamespace(ApiConsts.NAMESPC_DRBD_PEER_DEVICE_OPTIONS).isPresent())
            {
                appendLine("disk");
                try (Section ignore = new Section())
                {
                    appendDrbdOptions(
                        LinStorObject.CONTROLLER,
                        satelliteProps,
                        ApiConsts.NAMESPC_DRBD_DISK_OPTIONS
                    );

                    appendDrbdOptions(
                        LinStorObject.CONTROLLER,
                        satelliteProps,
                        ApiConsts.NAMESPC_DRBD_PEER_DEVICE_OPTIONS
                    );
                }
            }

            if (satelliteProps.getNamespace(ApiConsts.NAMESPC_DRBD_NET_OPTIONS).isPresent())
            {
                appendLine("net");
                try (Section ignore = new Section())
                {
                    appendDrbdOptions(
                        LinStorObject.CONTROLLER,
                        satelliteProps,
                        ApiConsts.NAMESPC_DRBD_NET_OPTIONS
                    );
                }
            }

            if (satelliteProps.getNamespace(ApiConsts.NAMESPC_DRBD_RESOURCE_OPTIONS).isPresent())
            {
                appendLine("options");
                try (Section ignore = new Section())
                {
                    appendDrbdOptions(
                        LinStorObject.CONTROLLER,
                        satelliteProps,
                        ApiConsts.NAMESPC_DRBD_RESOURCE_OPTIONS
                    );
                }
            }
        }

        return stringBuilder.toString();
    }

    private void appendDrbdOptions(
        final LinStorObject lsObj,
        final Props props,
        final String namespace
    )
    {
        Map<String, String> drbdProps = props.getNamespace(namespace)
            .map(Props::map).orElse(new HashMap<>());

        for (Map.Entry<String, String> entry : drbdProps.entrySet())
        {
            String key = entry.getKey();
            String value = entry.getValue();
            if (whitelistProps.isAllowed(lsObj, key, value, true))
            {
                appendLine("%s %s;",
                    key.substring(namespace.length() + 1),
                    value
                );
            }
            else
            {
                errorReporter.reportProblem(
                    Level.WARN,
                    new LinStorException(
                        "Ignoring property '" + key + "' with value '" + value + "' as it is not whitelisted."
                    ),
                    null,
                    null,
                    "The whitelist was generated from 'drbdsetup xml-help {resource,peer-device,net,disk}-options'" +
                    " when the satellite started.");
            }
        }
    }

    private NetInterface getPreferredNetIf(Resource rsc)
    {
        NetInterface preferredNetIf = null;
        try
        {
            Volume firstVlm = rsc.iterateVolumes().next();

            PriorityProps prioProps;
            prioProps = new PriorityProps(
                firstVlm.getStorPool(accCtx).getProps(accCtx),
                firstVlm.getProps(accCtx),
                rsc.getProps(accCtx),
                rsc.getAssignedNode().getProps(accCtx)
            );

            String prefNic = prioProps.getProp(ApiConsts.KEY_STOR_POOL_PREF_NIC);

            if (prefNic != null)
            {
                preferredNetIf = rsc.getAssignedNode().getNetInterface(
                    accCtx,
                    new NetInterfaceName(prefNic) // TODO: validate on controller
                );

                if (preferredNetIf == null)
                {
                    errorReporter.logWarning(
                        String.format("Preferred network interface '%s' not found, fallback to default", prefNic)
                    );
                }
            }

            // fallback if preferred couldn't be found
            if (preferredNetIf == null)
            {
                Node assgNode = rsc.getAssignedNode();
                // Try to find the 'default' network interface
                preferredNetIf = assgNode.getNetInterface(accCtx, NetInterfaceName.DEFAULT_NET_INTERFACE_NAME);
                // If there is not even a 'default', use the first one that is found in the node's
                // list of network interfaces
                if (preferredNetIf == null)
                {
                    preferredNetIf = assgNode.streamNetInterfaces(accCtx).findFirst().orElse(null);
                }
            }
        }
        catch (AccessDeniedException | InvalidKeyException | InvalidNameException implError)
        {
            throw new ImplementationError(implError);
        }

        return preferredNetIf;
    }

    private void appendVlmIfPresent(Volume vlm, AccessContext localAccCtx)
        throws AccessDeniedException
    {
        if (vlm.getFlags().isUnset(localAccCtx, Volume.VlmFlags.DELETE, Volume.VlmFlags.CLEAN))
        {
            final String disk;
            if (vlm.getBackingDiskPath(localAccCtx) == null ||
                vlm.getResource().getStateFlags().isSet(localAccCtx, RscFlags.DISKLESS))
            {
                disk = "none";
            }
            else
            {
                String tmpDisk = vlm.getBackingDiskPath(localAccCtx);
                if (tmpDisk.trim().equals(""))
                {
                    if (vlm.getResource().equals(localRsc))
                    {
                        throw new LinStorRuntimeException(
                            "Local volume does an empty block device. This might be result of an other error.",
                            "The storage driver returned an empty string instead of the path of the backing device",
                            "This is either an implementation error or just a side effect of an other " +
                                "recently occured error. Please check the error logs and try to solve the other " +
                                "other errors first",
                            null,
                            null
                        );
                    }
                    disk = "/dev/drbd/this/is/not/used";
                }
                else
                {
                    disk = vlm.getBackingDiskPath(localAccCtx);
                }
            }
            final String metaDisk;
            if (vlm.getMetaDiskPath(localAccCtx) == null)
            {
                metaDisk = "internal";
            }
            else
            {
                String tmpMeta = vlm.getMetaDiskPath(localAccCtx);
                if (tmpMeta.trim().equals(""))
                {
                    metaDisk = "internal";
                }
                else
                {
                    metaDisk = vlm.getMetaDiskPath(localAccCtx);
                }
            }

            final VolumeDefinition vlmDfn = vlm.getVolumeDefinition();
            appendLine("volume %s", vlmDfn.getVolumeNumber().value);
            try (Section volumeSection = new Section())
            {
                appendLine("disk        %s;", disk);

                if (vlmDfn.getProps(accCtx).getNamespace(ApiConsts.NAMESPC_DRBD_DISK_OPTIONS).isPresent())
                {
                    appendLine("disk");
                    try (Section ignore = new Section())
                    {
                        appendDrbdOptions(
                            LinStorObject.CONTROLLER,
                            vlmDfn.getProps(accCtx),
                            ApiConsts.NAMESPC_DRBD_DISK_OPTIONS
                        );
                    }
                }

                appendLine("meta-disk   %s;", metaDisk);
                appendLine("device      minor %d;",
                    vlm.getVolumeDefinition().getMinorNr(localAccCtx).value
                // TODO: impl and ask storPool for device
                );
                // TODO: add "disk { ... }" section
            }
        }
    }

    private void appendIndent()
    {
        for (int idx = 0; idx < indentDepth; idx++)
        {
            stringBuilder.append("    ");
        }
    }

    private void append(String format, Object... args)
    {
        stringBuilder.append(String.format(format, args));
    }

    private void appendLine(String format, Object... args)
    {
        appendIndent();
        append(format, args);
        stringBuilder.append("\n");
    }

    private static class ResourceNameComparator implements Comparator<Resource>
    {
        @Override
        public int compare(Resource o1, Resource o2)
        {
            return o1.getAssignedNode().getName().compareTo(o2.getAssignedNode().getName());
        }
    }

    /**
     * Allows a section to be expressed using try-with-resources so that it is automatically closed.
     * <p>
     * Non-static to allow access to the indentDepth.
     */
    private class Section implements AutoCloseable
    {
        Section()
        {
            appendLine("{");
            indentDepth++;
        }

        @Override
        public void close()
        {
            indentDepth--;
            appendLine("}");
        }
    }
}
